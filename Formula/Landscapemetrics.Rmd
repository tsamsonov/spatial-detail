---
title: "Landscape metrics"
output: bookdown::html_document2
---

```{r setup, echo=FALSE, include=FALSE}
knitr::opts_chunk$set(fig.height = 6, fig.width = 6, collapse = TRUE, 
                      echo = FALSE, message = FALSE, warning = FALSE)
library(landscapemetrics)
library(patchwork)
library(tidyverse)
library(ggrepel)
library(readxl)
library(stars)
```

```{r}
# Ландшафтные данные

typesdf = read_excel('data/types.xlsx')
types = typesdf$type

read_lc = function(file) {
  read_stars(file) %>% 
    select(type = 1) %>%
    mutate(typefac = factor(type, levels = types),
           urban = (type == 50),
           crops = (type == 40)) %>% 
    st_warp(crs = 32662)
}

salekhard = read_lc('data/SALEKHARD.tif')
moscow = read_lc('data/MOSCOW.tif')
rostov = read_lc('data/ROSTOV.tif')
ufa = read_lc('data/UFA.tif')
petro = read_lc('data/PETRO.tif')
surgut = read_lc('data/SURGUT.tif')
sharia = read_lc('data/USTUG.tif')
grozny = read_lc('data/GROZNY.tif')
voronezh = read_lc('data/VORONEZH.tif')

lands = lst(САЛЕХАРД = salekhard, МОСКВА = moscow, `РОСТОВ-НА-ДОНУ` = rostov, 
            УФА = ufa, ПЕТРОЗАВОДСК = petro, ШАРЬЯ = sharia, ГРОЗНЫЙ = grozny, 
            ВОРОНЕЖ = voronezh, СУРГУТ = surgut)

(metrics = imap(lands, function(land, name) {
  tibble(name = name,
         ent = lsm_l_ent(land) %>% pull(value),
         condent = lsm_l_condent(land) %>% pull(value),
         joinent = lsm_l_joinent(land) %>% pull(value),
         mutinf = lsm_l_mutinf(land) %>% pull(value),
         relmutinf = mutinf / ent,
         urban = 100 * sum(land$urban, na.rm = TRUE) / length(land$urban),
         crops = 100 * sum(land$crops, na.rm = TRUE) / length(land$crops))
}) %>% bind_rows())
```

```{r}
colormap = read_table2('data/colormap.clr', 
                       col_names = c('N', 'R', 'G', 'B', 'A', 'type')) %>% 
  filter(type %in% types)

pal = rgb(colormap$R/255, colormap$G/255, colormap$B/255, colormap$A/255)

plot_lc = function(lc) {
  ggplot() +
    geom_stars(data = lc['typefac']) +
    scale_fill_manual(values = pal, breaks = types, labels = typesdf$class, drop = FALSE) +
    coord_sf(crs = st_crs(lc)) +
    xlab('LON') + ylab('LAT') +
    theme_bw() + theme(legend.position = 'bottom', legend.title=element_blank()) +
    guides(fill = guide_legend(ncol=4))
}
```

```{r}
# Векторные данные

scales = c(200, 500, 1000)
regions = c('МОСКВА', 'ПЕТРОЗАВОДСК', 'САЛЕХАРД', 'УФА', 'РОСТОВ-ДОН')

read_data = function(file) {
  lapply(scales, function(scale) { 
    read_delim(paste0(file, scale, '.txt'), delim = ';', locale = locale(decimal_mark = ".")) %>% 
    select(-ncol(.)) %>% 
    mutate(Scale = scale,
           Region = stringr::str_sub(Region, 1, nchar(Region) - nchar(as.character(Scale))))
  }) %>% 
    bind_rows() %>% 
    filter(!stringr::str_detect(Name, 'clip')) %>% 
    mutate(Layer = stringr::str_sub(Name, 1, 3),
           Dim = stringr::str_sub(Name, 4, 6)) %>% 
    filter(!(Layer %in% c('rlh', 'rlf', 'veg', 'hdr', 'hdt', 'hdc', 'for'))) %>% 
    mutate_all(~replace(., is.nan(.), 0)) %>% 
    group_by(Scale) %>% 
    complete(Region, Layer) %>% 
    ungroup() %>% 
    mutate(missing = ifelse(is.na(Name), Layer, NA)) %>% 
    filter(!(Layer %in% unique(missing))) %>% 
    distinct(Scale, Region, Layer, .keep_all = TRUE)
}

lindata = read_data('tables/resLines')
pntdata = read_data('tables/resPoints')
poldata = read_data('tables/resPolygons')

nuniq = length(unique(poldata$Region))

inters = read_delim('tables/topLines.txt', delim = ';', locale = locale(decimal_mark = ".")) %>% 
  select(-ncol(.)) %>% 
  mutate(Scale = rep(scales, each = n()/3),
         Region = stringr::str_sub(Region, 1, nchar(Region) - nchar(Scale)),
         Region = ifelse(Region == 'РОСТОВ-ДОН', 'РОСТОВ-НА-ДОНУ',
                       ifelse(Region == 'УСТЮГ', 'ШАРЬЯ', Region))) %>% 
  rename(name = Region,
         intersections = Intersections)
```

```{r}
# Подсчитаем суммарное количество социально-экономических точек
linstats = lindata %>% 
  filter(NumberOfObj > 0) %>% 
  group_by(Region, Scale) %>% 
  summarise(linnpts = sum(PointsNumber),
            height = weighted.mean(AverageHeight, NumberOfObj),
            width = weighted.mean(AverageWidth, NumberOfObj),
            numlin = sum(NumberOfObj))
polstats = poldata %>% 
  filter(NumberOfObj > 0) %>% 
  group_by(Region, Scale) %>% 
  summarise(polnpts = sum(PointsNumber),
            numpol = sum(NumberOfObj),
            minarea = min(AveArea),
            area = 1e-6 * sum(TotalArea * (Layer == 'adm')))
pntstats = pntdata %>% 
  filter(NumberOfObj > 0) %>% 
  group_by(Region, Scale) %>% 
  summarise(pntnpts = sum(NumberOfObj),
            numpts = sum(NumberOfObj))


stats = bind_cols(linstats, polstats, pntstats) %>% 
  select(name = Region, Scale, pntnpts, linnpts, polnpts, 
         numlin, numpts, numpol, area, minarea, height, width) %>% 
  mutate(total = pntnpts + linnpts + polnpts,
         num = numlin + numpts + numpol,
         pnt_density = 100 * total / area,
         obj_density = 100 * num / area) %>% 
  ungroup() %>% 
  mutate(name = ifelse(name == 'РОСТОВ-ДОН', 'РОСТОВ-НА-ДОНУ',
                       ifelse(name == 'УСТЮГ', 'ШАРЬЯ', name)))

tab = stats %>% 
  left_join(inters) %>% 
  mutate(Scale = factor(Scale, levels = c(200, 500, 1000)),
         int_density = 100 * intersections / area) %>% 
  left_join(metrics)
  
```

> __Задача:__ Разработка метрик и программного обеспечения для оценки детализации множества пространственных объектов, а также детализации карты (базы пространственных данных) в целом на основе учета геометрических, семантических и символьных (применяемых при отображении) параметров. Оценка устойчивости и сопоставимости рассчитанных значений метрик для фрагментов данных, извлеченных из топографических карт одного и разных масштабов.

В рамках работ 2019 г были проведены эксперименты с целью выработки понимания того, каким образом можно оценить детализацию карты в числовой форме. Детализация карт регламентируется только для топографических продуктов, и происходит это в неявной форме. С одной стороны, для каждого масштаба существуют цензы отбора, устанавливающие по геометрическим и семантическим параметрам минимальный порог вхождения объектов и модель их пространственной локализации (точка, линия, полигоны). С другой стороны, устанавливаются нормы отбора, регламентирующие максимально допустимое количество объектов на единицу площади. Наконец, ограничения визуального восприятия устанавливают графическую точность изображения порядка 0,1 мм, что в свою очередь регламентирует минимальный размер деталей (изгибов) в составе изображаемых линий. Эти три компоненты — цензы, нормы и графическая точность — в совокупности определяют детализацию представления информации на карте.

Проведенные в 2018 г. эксперименты показали, что существуют индивидуальные характристики объектов, такие как средняя площадь изгибов, которые систематически изменяются при переходе с одного масштаба (уровня детализации) на другой. Однако при переходе к оценке детализации однородных множеств пространственных объектов (слоёв), таких как объекты гидрографии или транспортные коммуникации, а также оценке детализации карты как совокупности этих множеств, необходимо учитывать также количество объектов на единицу площади и их топологические отношения. При уменьшении масштаба картыв связи с отбором количество объектов на единицу площади поврехности Земли уменьшается, что по логике должно свидетельствовать об уменьшении детализации представления. Соответствующим образом должно уменьшаться и количество пересечений между объектами внутри одного слоя и между слоями.

Рассуждая подобным образом, можно придти к выводу, что для оценки детализации карты можно воспользоваться плотностными показателями, такими как как плотность объектов, плотность вершин, плотность пересечений между объектами, а также показателями размера, такими как средняя ширина и высота изгиба линии (применима как к линейным объектам, так и к площадным). Для выполнения эксперимента мы выбрали 9 фрагментов цифровых топографических карт масштабов 1:200 000, 1:500 000 и 1:1 000 000 с охватом порядка $200\times200~км$ в окрестностях городов Воронеж, Грозный, Москва, Петрозаводск, Ростов-на-Дону, Салехард, Сургут, Уфа и Шарья. 

Использовались данные по социально-экономическим объектам (населенные пункты и их структура, транспорт, инженерные коммуникации, административно-территориальное деление). Результаты по трем плотностным геометрическим характеристикам представлены на Рис. \@ref(fig:denstats).

```{r denstats, fig.width=5, fig.height=7, fig.cap='Относительные параметры геометрической детализации карты (плотность)'}
p1 = ggplot(tab, mapping = aes(name, pnt_density, fill = Scale)) +
  geom_col(position = "dodge") +
  coord_flip() +
  xlab(NULL) +
  guides(fill = guide_legend(reverse=T)) +
  ggtitle('Плотность точек на 100 кв. км')

p2 = ggplot(tab, mapping = aes(name, obj_density, fill = Scale)) +
  geom_col(position = "dodge") +
  coord_flip() +
  xlab(NULL) +
  guides(fill = guide_legend(reverse=T)) +
  ggtitle('Плотность объектов на 100 кв. км')

p3 = ggplot(tab, mapping = aes(name, int_density, fill = Scale)) +
  geom_col(position = "dodge") +
  coord_flip() +
  xlab(NULL) +
  guides(fill = guide_legend(reverse=T)) +
  ggtitle('Плотность пересечений на 100 кв. км')

(p1 / p2 / p3) + plot_annotation(tag_levels = 'a', tag_suffix = ')')
```

Анализ полученных результатов показывает, что плотностные характеристики не являются надежными индикаторами уровня детализации. Даже в пределах одного масштаба плотность размещения объектов может отличаться на порядки. Например, для участка Воронеж в масштабе 1:200 000 плотность объектов составляет $74,7$ на $100~км^2$, в то время как для участка Салехард всего лишь $1,9$. Подобный разброс наблюдается во всех масштабах и для всех исследуемых величин (плотность точек, объектов, пересечений), хотя следует отметить что с уменьшением масштаба разброс становится менее радикальным (Рис. \@ref(fig:densbox)). Тем не менее, выполнение теста Стьюдента на отличие средних между масштабными группами показывает статистическую надежность этих отличий с уровнем значимости ниже $0.05$.

```{r densbox, fig.width=5, fig.height=2.5, fig.cap='Разброс относительных параметров геометрической детализации карты (плотность)'}
p1 = ggplot(tab, mapping = aes(Scale, pnt_density, fill = Scale)) +
  geom_boxplot() +
  ylab('на 100 кв. км') +
  theme(legend.position = "none") +
  ggtitle('Плотность точек')

p2 = ggplot(tab, mapping = aes(Scale, obj_density, fill = Scale)) +
  geom_boxplot() +
  ylab('на 100 кв. км') +
  theme(legend.position = "none") +
  ggtitle('Плотность объектов')

p3 = ggplot(tab, mapping = aes(Scale, int_density, fill = Scale)) +
  geom_boxplot() +
  ylab('на 100 кв. км') +
  ggtitle('Плотность пересечений')

(p1 | p2 | p3) + plot_annotation(tag_levels = 'a', tag_suffix = ')')
```

Абсолютные характеристики детализации, представленные на Рис. \@ref(fig:sizestats), демонстрируют более устойчивое поведение, однако и в этом случае диапазон разброса значений может отличаться в несколько раз: для тех же участков Салехард и Воронеж в масштабе 1:200 000 отношения средних ширин и высот составляет $3.8$ и $2.7$ соответственно. Наиболее стабильный характер имеет минимальная средняя площадь полигонального объекта (Рис. \@ref(fig:sizestats)c), вычисленная как минимум из средних площадей объектов каждого слоя. Тем не менее, и по данной характеристике могут наблюдаться выбросы. Так, например, в масштабе 1:1 000 000 для участка Салехард минимальная площадь полигонального объекта в 136 раз больше следующего по размеру минимальной средней площади участка Сургут. 

```{r sizestats, fig.width=5, fig.height=7, fig.cap='Абсолютные параметры геометрической детализации карты (размеры)'}
p4 = ggplot(tab, mapping = aes(name, width, fill = Scale)) +
  geom_col(position = "dodge") +
  coord_flip() +
  theme(legend.position = "none") +
  xlab(NULL) +
  ggtitle('Средняя ширина изгиба')

p5 = ggplot(tab, mapping = aes(name, height, fill = Scale)) +
  geom_col(position = "dodge") +
  coord_flip() +
  theme(legend.position = "none") +
  xlab(NULL) +
  ggtitle('Средняя высота изгиба')

p6 = ggplot(tab, mapping = aes(name, minarea, fill = Scale)) +
  geom_col(position = "dodge") +
  coord_flip() +
  scale_y_log10() +
  xlab(NULL) +
  ggtitle('Минимальная средняя площадь объекта')

(p4 / p5 / p6) + plot_annotation(tag_levels = 'a', tag_suffix = ')')
```

В целом более качественная разделимость уровней детализации по абсолютным характеристикам в сравнении с относительными подтверждается диаграммами размаха, представленными на Рис. \@ref(fig:sizebox), а также результатами теста Стьюдента, подтверждающего отличия в средних на уровне значимости ниже $0.05$.

```{r sizebox, fig.width=5, fig.height=2.5, fig.cap='Разброс абсолютных параметров геометрической детализации карты (плотность)'}
p4 = ggplot(tab, mapping = aes(Scale, width, fill = Scale)) +
  geom_boxplot() +
  ylab('км') +
  theme(legend.position = "none") +
  ggtitle('Средняя ширина изгиба')

p5 = ggplot(tab, mapping = aes(Scale, height, fill = Scale)) +
  geom_boxplot() +
  ylab('км') +
  theme(legend.position = "none") +
  ggtitle('Средняя высота изгиба')

p6 = ggplot(tab, mapping = aes(Scale, minarea, fill = Scale)) +
  geom_boxplot() +
  scale_y_log10() +
  ylab('кв. км') +
  ggtitle('Минимальная средняя площадь')

(p4 | p5 | p6) + plot_annotation(tag_levels = 'a', tag_suffix = ')')
```

Карты земельного покрова для данных участков показаны на Рис. \@ref(fig:sal) — \@ref(fig:vor)
```{r sal, fig.width=6, fig.height=6, fig.cap='Типы земельного покрова по данным Copernicus Global Land Cover (участок Салехард)'}
plot_lc(salekhard)
```

```{r mos, fig.width=6, fig.height=6, fig.cap='Типы земельного покрова по данным Copernicus Global Land Cover (участок Москва)'}
plot_lc(moscow)
```

```{r ros, fig.width=6, fig.height=6, fig.cap='Типы земельного покрова по данным Copernicus Global Land Cover (участок Ростов-на-Дону)'}
plot_lc(rostov)
```

```{r ufa, fig.width=6, fig.height=6, fig.cap='Типы земельного покрова по данным Copernicus Global Land Cover (участок Уфа)'}
plot_lc(ufa)
```

```{r pet, fig.width=6, fig.height=6, fig.cap='Типы земельного покрова по данным Copernicus Global Land Cover (участок Петрозаводск)'}
plot_lc(petro)
```

```{r sur, fig.width=6, fig.height=6, fig.cap='Типы земельного покрова по данным Copernicus Global Land Cover (участок Сургут)'}
plot_lc(surgut)
```

```{r sha, fig.width=6, fig.height=6, fig.cap='Типы земельного покрова по данным Copernicus Global Land Cover (участок Шарья)'}
plot_lc(sharia)
```

```{r gro, fig.width=6, fig.height=6, fig.cap='Типы земельного покрова по данным Copernicus Global Land Cover (участок Грозный)'}
plot_lc(grozny)
```

```{r vor, fig.width=6, fig.height=6, fig.cap='Типы земельного покрова по данным Copernicus Global Land Cover (участок Воронеж)'}
plot_lc(voronezh)
```


Корреляционный и регрессионный анализ

```{r, fig.height=4, fig.width=4}
var = 'obj_density'
y = pull(tab, var)

plot_lm = function(var1, var2) {
  ggplot(tab, mapping = aes_string(var1, var2, group = 'Scale', color = 'Scale', label = 'name')) +
    geom_point() +
    geom_smooth(method = 'lm') +
    geom_text_repel(
      segment.size  = 0.3,
      segment.color = "grey50",
      direction     = "y",
      hjust         = 0
    ) +
    scale_x_log10()
}

plot_lm('urban', var)
plot_lm('crops', var)

ggplot(tab, mapping = aes(ent, pnt_density, color = Scale, label = name)) +
  geom_point() +
  geom_text_repel(
    segment.size  = 0.3,
    segment.color = "grey50",
    direction     = "y",
    hjust         = 0
  )

cor.test(y, log(tab$urban + 1))
cor.test(y, log(tab$crops + 1))
cor.test(y, log(tab$crops + 1) + log(tab$urban + 1))

lm(y ~ log(tab$urban + 1))
lm(y ~ log(tab$crops + 1))
lm(y ~ log(tab$crops + 1) + log(tab$urban + 1))
```










